"use strict";(self["webpackChunkelsaify"]=self["webpackChunkelsaify"]||[]).push([[176],{3176:function(t,e,r){r.r(e),r.d(e,{FilesystemWeb:function(){return a}});var i=r(9895);function o(t){const e=t.split("/").filter((t=>"."!==t)),r=[];return e.forEach((t=>{".."===t&&r.length>0&&".."!==r[r.length-1]?r.pop():r.push(t)})),r.join("/")}function s(t,e){t=o(t),e=o(e);const r=t.split("/"),i=e.split("/");return t!==e&&r.every(((t,e)=>t===i[e]))}class a extends i.Uw{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"]}async initDb(){if(void 0!==this._db)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise(((t,e)=>{const r=indexedDB.open(this.DB_NAME,this.DB_VERSION);r.onupgradeneeded=a.doUpgrade,r.onsuccess=()=>{this._db=r.result,t(r.result)},r.onerror=()=>e(r.error),r.onblocked=()=>{console.warn("db blocked")}}))}static doUpgrade(t){const e=t.target,r=e.result;switch(t.oldVersion){case 0:case 1:default:{r.objectStoreNames.contains("FileStorage")&&r.deleteObjectStore("FileStorage");const t=r.createObjectStore("FileStorage",{keyPath:"path"});t.createIndex("by_folder","folder")}}}async dbRequest(t,e){const r=-1!==this._writeCmds.indexOf(t)?"readwrite":"readonly";return this.initDb().then((i=>new Promise(((o,s)=>{const a=i.transaction(["FileStorage"],r),n=a.objectStore("FileStorage"),c=n[t](...e);c.onsuccess=()=>o(c.result),c.onerror=()=>s(c.error)}))))}async dbIndexRequest(t,e,r){const i=-1!==this._writeCmds.indexOf(e)?"readwrite":"readonly";return this.initDb().then((o=>new Promise(((s,a)=>{const n=o.transaction(["FileStorage"],i),c=n.objectStore("FileStorage"),d=c.index(t),h=d[e](...r);h.onsuccess=()=>s(h.result),h.onerror=()=>a(h.error)}))))}getPath(t,e){const r=void 0!==e?e.replace(/^[/]+|[/]+$/g,""):"";let i="";return void 0!==t&&(i+="/"+t),""!==e&&(i+="/"+r),i}async clear(){const t=await this.initDb(),e=t.transaction(["FileStorage"],"readwrite"),r=e.objectStore("FileStorage");r.clear()}async readFile(t){const e=this.getPath(t.directory,t.path),r=await this.dbRequest("get",[e]);if(void 0===r)throw Error("File does not exist.");return{data:r.content?r.content:""}}async writeFile(t){const e=this.getPath(t.directory,t.path),r=t.data,i=t.recursive,o=await this.dbRequest("get",[e]);if(o&&"directory"===o.type)throw Error("The supplied path is a directory.");const s=t.encoding,a=e.substr(0,e.lastIndexOf("/")),n=await this.dbRequest("get",[a]);if(void 0===n){const e=a.indexOf("/",1);if(-1!==e){const r=a.substr(e);await this.mkdir({path:r,directory:t.directory,recursive:i})}}const c=Date.now(),d={path:e,folder:a,type:"file",size:r.length,ctime:c,mtime:c,content:!s&&r.indexOf(",")>=0?r.split(",")[1]:r};return await this.dbRequest("put",[d]),{uri:d.path}}async appendFile(t){const e=this.getPath(t.directory,t.path);let r=t.data;const i=e.substr(0,e.lastIndexOf("/")),o=Date.now();let s=o;const a=await this.dbRequest("get",[e]);if(a&&"directory"===a.type)throw Error("The supplied path is a directory.");const n=await this.dbRequest("get",[i]);if(void 0===n){const e=i.indexOf("/",1);if(-1!==e){const r=i.substr(e);await this.mkdir({path:r,directory:t.directory,recursive:!0})}}void 0!==a&&(r=a.content+r,s=a.ctime);const c={path:e,folder:i,type:"file",size:r.length,ctime:s,mtime:o,content:r};await this.dbRequest("put",[c])}async deleteFile(t){const e=this.getPath(t.directory,t.path),r=await this.dbRequest("get",[e]);if(void 0===r)throw Error("File does not exist.");const i=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(e)]);if(0!==i.length)throw Error("Folder is not empty.");await this.dbRequest("delete",[e])}async mkdir(t){const e=this.getPath(t.directory,t.path),r=t.recursive,i=e.substr(0,e.lastIndexOf("/")),o=(e.match(/\//g)||[]).length,s=await this.dbRequest("get",[i]),a=await this.dbRequest("get",[e]);if(1===o)throw Error("Cannot create Root directory");if(void 0!==a)throw Error("Current directory does already exist.");if(!r&&2!==o&&void 0===s)throw Error("Parent directory must exist");if(r&&2!==o&&void 0===s){const e=i.substr(i.indexOf("/",1));await this.mkdir({path:e,directory:t.directory,recursive:r})}const n=Date.now(),c={path:e,folder:i,type:"directory",size:0,ctime:n,mtime:n};await this.dbRequest("put",[c])}async rmdir(t){const{path:e,directory:r,recursive:i}=t,o=this.getPath(r,e),s=await this.dbRequest("get",[o]);if(void 0===s)throw Error("Folder does not exist.");if("directory"!==s.type)throw Error("Requested path is not a directory");const a=await this.readdir({path:e,directory:r});if(0!==a.files.length&&!i)throw Error("Folder is not empty");for(const n of a.files){const t=`${e}/${n}`,o=await this.stat({path:t,directory:r});"file"===o.type?await this.deleteFile({path:t,directory:r}):await this.rmdir({path:t,directory:r,recursive:i})}await this.dbRequest("delete",[o])}async readdir(t){const e=this.getPath(t.directory,t.path),r=await this.dbRequest("get",[e]);if(""!==t.path&&void 0===r)throw Error("Folder does not exist.");const i=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(e)]),o=i.map((t=>t.substring(e.length+1)));return{files:o}}async getUri(t){const e=this.getPath(t.directory,t.path);let r=await this.dbRequest("get",[e]);return void 0===r&&(r=await this.dbRequest("get",[e+"/"])),{uri:(null===r||void 0===r?void 0:r.path)||e}}async stat(t){const e=this.getPath(t.directory,t.path);let r=await this.dbRequest("get",[e]);if(void 0===r&&(r=await this.dbRequest("get",[e+"/"])),void 0===r)throw Error("Entry does not exist.");return{type:r.type,size:r.size,ctime:r.ctime,mtime:r.mtime,uri:r.path}}async rename(t){return this._copy(t,!0)}async copy(t){return this._copy(t,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(t,e=!1){let{toDirectory:r}=t;const{to:i,from:o,directory:a}=t;if(!i||!o)throw Error("Both to and from must be provided");r||(r=a);const n=this.getPath(a,o),c=this.getPath(r,i);if(n===c)return;if(s(n,c))throw Error("To path cannot contain the from path");let d;try{d=await this.stat({path:i,directory:r})}catch(u){const t=i.split("/");t.pop();const e=t.join("/");if(t.length>0){const t=await this.stat({path:e,directory:r});if("directory"!==t.type)throw new Error("Parent directory of the to path is a file")}}if(d&&"directory"===d.type)throw new Error("Cannot overwrite a directory with a file");const h=await this.stat({path:o,directory:a}),l=async(t,e,i)=>{const o=this.getPath(r,t),s=await this.dbRequest("get",[o]);s.ctime=e,s.mtime=i,await this.dbRequest("put",[s])},y=h.ctime?h.ctime:Date.now();switch(h.type){case"file":{const t=await this.readFile({path:o,directory:a});return e&&await this.deleteFile({path:o,directory:a}),await this.writeFile({path:i,directory:r,data:t.data}),void(e&&await l(i,y,h.mtime))}case"directory":{if(d)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:i,directory:r,recursive:!1}),e&&await l(i,y,h.mtime)}catch(u){}const t=(await this.readdir({path:o,directory:a})).files;for(const s of t)await this._copy({from:`${o}/${s}`,to:`${i}/${s}`,directory:a,toDirectory:r},e);e&&await this.rmdir({path:o,directory:a})}}}}a._debug=!0}}]);
//# sourceMappingURL=176.6627d39c.js.map